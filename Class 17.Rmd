---
title: "Bioinformatics Class 17"
author: "Pallas Duong"
date: "5/29/2018"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

#**Section 1:** Set up Cytoscape and the igraph R package 

Load packages
```{r}
library(RCy3)
library(igraph)
library(RColorBrewer)
```

##Make sure Cytoscape is up and running
Cystoscape software must be running 

##First contact 
Verify a connection to Cystoscape and for logging the versions of CyREST and Cytoscape 
```{r}
cwd <- demoSimpleGraph()
```

Layout
```{r}
layoutNetwork(cwd, 'force-directed')

#Choose any of the other possible layouts 
possible.layout.names <- getLayoutNames(cwd)
layoutNetwork(cwd, possible.layout.names[1])

#Test the connection to Cystoscape
ping(cwd)
```

##Switch Styles 
Marquee style 
```{r}
setVisualStyle(cwd, "Marquee")
```

Show the result in R
```{r}
saveImage(cwd, 
          file.name = "demo",
          image.type = "png",
          h = 350)
```

Open the image 
```{r}
library(knitr)
include_graphics("demo.png")
```

Other styles
```{r}
styles <- getVisualStyleNames(cwd)
styles
```

Try other styles 
```{r}
#setVisualStyle(cwd, styles[18])
```

#**Section 2:** Read our metagenomicsd data

Process located in "inst/data-raw/"
```{r}
prok_vir_cor <- read.delim("virus_prok_cor_abundant.tsv")
head(prok_vir_cor)
```

Use igraph package to convert hte co-occurence dataframe into a network that we can send to Cytoscape
```{r}
g <- graph.data.frame(prok_vir_cor, directed = FALSE)
```

Check the calss of 'g'
```{r}
class(g)
```

Therefore print.igraph() function will be called when we type it's name allowing us have an informative overview of the graph structure 
```{r}
g
```

In this case the first line of output (“UNW- 854 1544 –”) tells that our network graph has 845 vertices (i.e. nodes, which represent our bacteria and viruses) and 1544 edges (i.e. linking lines, which indicate their co-occurrence). Note that the first four characters (i.e. the “UNW-” part) tell us about the network setup. In this case our network is Undirected, Named (i.e. has the ‘name’ node/vertex attribute set) and Weighted (i.e. the ‘weight’ edge attribute is set).

Common igraph functions for creating network graphs include: graph_from_data_frame(), graph_from_edgelist(), and graph_from_adjacency_matrix(). You can find out more about these functions from their associated help pages.

Graph
```{r}
plot(g)
#Too dense
```


Tune plot attributes (igraph.plotting). Turn down vertext size from the default value of 15 and turn off vertex labels
```{r}
plot(g, vertex.size=3, vertex.label=NA)
```

Query (and set) vertex and edge attributes with the V() and E() function 
```{r}
V(g)

E(g)
```

There are also the functions vertex.attributes() and edge.attributes() that query all vertex and edge attributes of a igraph object.

#**Section 3:** Read in taxonomic classification 

Read phage's data
```{r}
phage_id_affiliation <- read.delim("./data/phage_ids_with_affiliation.tsv")
head(phage_id_affiliation)
```

Read bateria's data
```{r}
bac_id_affi <- read.delim("./data/prok_tax_from_silva.tsv")
head(bac_id_affi)
```

#**Section 4:** Add the taxonomic classifications to the netweok and then send netweok to Cytoscape 

Create gene network 'genenet' for cytoscape
```{r}
genenet.nodes <- as.data.frame(vertex.attributes(g))
```

Not all have classification, so creaty empty columns
```{r}
genenet.nodes$phage_aff <- rep("not_class", nrow(genenet.nodes))
genenet.nodes$Tax_order <- rep("not_class", nrow(genenet.nodes))
genenet.nodes$Tax_subfamily <- rep("not_class", nrow(genenet.nodes))

for (row in seq_along(1:nrow(genenet.nodes))){
  if (genenet.nodes$name[row] %in% phage_id_affiliation$first_sheet.Phage_id_network){
    id_name <- as.character(genenet.nodes$name[row])
    aff_to_add <- unique(subset(phage_id_affiliation,
                                first_sheet.Phage_id_network == id_name,
                                select = c(phage_affiliation,
                                           Tax_order,
                                           Tax_subfamily)))
    genenet.nodes$phage_aff[row] <- as.character(aff_to_add$phage_affiliation)
    genenet.nodes$Tax_order[row] <- as.character(aff_to_add$Tax_order)
    genenet.nodes$Tax_subfamily[row] <- as.character(aff_to_add$Tax_subfamily)
  }
}
```

Do the same for proks
```{r}
genenet.nodes$prok_king <- rep("not_class", nrow(genenet.nodes))
genenet.nodes$prok_tax_phylum <- rep("not_class", nrow(genenet.nodes))
genenet.nodes$prok_tax_class <- rep("not_class", nrow(genenet.nodes))

for (row in seq_along(1:nrow(genenet.nodes))){
  if (genenet.nodes$name[row] %in% bac_id_affi$Accession_ID){
    aff_to_add <- unique(subset(bac_id_affi,
                                Accession_ID == as.character(genenet.nodes$name[row]),
                                select = c(Kingdom,
                                           Phylum,
                                           Class)))
    
    genenet.nodes$prok_king[row] <- as.character(aff_to_add$Kingdom)
    genenet.nodes$prok_tax_phylum[row] <- as.character(aff_to_add$Phylum)
    genenet.nodes$prok_tax_class[row] <- as.character(aff_to_add$Class)
  }
}
```

Add to the network the data related to the connections between the organisms, the edge data, and then prepare to send the nodes and edges to Cytoscpe using hte fucntion cyPlot()
```{r}
genenet.edges <- data.frame(igraph::as_edgelist(g))
names(genenet.edges) <- c("name.1", "name.2")

genenet.edges$Weight <- igraph::edge_attr(g)[[1]]

genenet.edges$name.1 <- as.character(genenet.edges$name.1)
genenet.edges$name.2 <- as.character(genenet.edges$name.2)
genenet.nodes$name <- as.character(genenet.nodes$name)

ug <- cyPlot(genenet.nodes,genenet.edges)

```

##Send network to Cytoscpae using RCy3

Delete any windows that were already in Cytoscpe so that we don't use up all our memory
```{r}
cy <- CytoscapeConnection()
deleteAllWindows(cy)
```

```{r}
cw <- CytoscapeWindow("Tara oceans",
                      graph = ug,
                      overwriteWindow = TRUE)
displayGraph(cw)
layoutNetwork(cw)
fitContent(cw)
```

#**Section 5:** Color network by prokaryotic phylum

Color different nodes based on their phylum classification 
```{r}
families_to_colour <- unique(genenet.nodes$prok_tax_phylum)
families_to_colour <- families_to_colour[!families_to_colour %in% "not_class"]
node.colour <- RColorBrewer::brewer.pal(length(families_to_colour), "Set3")
```

Use colors from Rcolorbrewer to color the nodes in Cytoscape
```{r}
setNodeColorRule(cw,
                 "prok_tax_phylum",
                 families_to_colour,
                 node.colour,
                 "lookup",
                 default.color = "#ffffff")
```

Display
```{r}
displayGraph(cw)
layoutNetwork(cw)
fitContent(cw)
```

##Set node shape to reflect virus or prokaryote
Set the viral nodes to be diamond-shapes by looking for all the nodes that start with "ph" in the network
```{r}
shapes_for_nodes <- c("DIAMOND")

phage_names <- grep("ph_",
                    genenet.nodes$name,
                    value = TRUE)
setNodeShapeRule(cw,
                 "label",
                 phage_names,
                 shapes_for_nodes)
```

Display
```{r}
displayGraph(cw)
fitContent(cw)

```

##Set edges of phage nodes 
```{r}
setDefaultNodeBorderWidth(cw, 5)
families_to_colour <- c(" Podoviridae",
                        " Siphoviridae",
                        " Myoviridae")
node.colour <- RColorBrewer::brewer.pal(length(families_to_colour),
                          "Dark2")
setNodeBorderColorRule(cw,
                       "Tax_subfamily",
                       families_to_colour,
                       node.colour,
                       "lookup", 
                       default.color = "#000000")
```

Display
```{r}
displayGraph(cw)
fitContent(cw)
```

#**Section 6:** Setup a layout to minimize overlap of nodes 
When using RCy3 to drive Cytoscape, if we are not sure what the current values are for a layout or we are not sure what kinds of values are accepted for the different parameters of our layout, we can investigate using the RCy3 functions getLayoutPropertyNames() and then getLayoutPropertyValue().

```{r}
getLayoutNames(cw)
getLayoutPropertyNames(cw, layout.name="force-directed")
getLayoutPropertyValue(cw, "force-directed", "defaultSpringLength") 
getLayoutPropertyValue(cw, "force-directed", "numIterations")  

```

Set them up
```{r}
setLayoutProperties(cw,
                    layout.name = "force-directed",
                    list(defaultSpringLength = 20,
                         "numIterations" = 200))
layoutNetwork(cw,
              layout.name = "force-directed")
fitContent(cw)

layoutNetwork(cw, layout.name = "force-directed")
fitContent(cw)
```

#**Section 7:** Examine network properties 

Initiate the new node attribute
```{r}
ug2 <- initNodeAttribute(graph = ug,
                          "degree",
                          "numeric",
                          0.0) 
##degree from graph package for undirected graphs not working well,
## so instead using igraph to calculate this from the original graph
nodeData(ug2, nodes(ug2), "degree") <- igraph::degree(g)

cw2 <- CytoscapeWindow("Tara oceans with degree",
                      graph = ug2,
                      overwriteWindow = TRUE)
displayGraph(cw2)
layoutNetwork(cw2)
```

#Size by degree
```{r}
degree_control_points <- c(min(igraph::degree(g)),
                           mean(igraph::degree(g)),
                           max(igraph::degree(g)))
node_sizes <- c(20,
                20,
                80,
                100,
                110) # number of control points in interpolation mode,
                     # the first and the last are for sizes "below" and "above" the attribute seen.

setNodeSizeRule(cw2,
                "degree",
                degree_control_points,
                node_sizes,
                mode = "interpolate")

layoutNetwork(cw2,
              "force-directed")
```

#**Section 8:** Select an interesting node and make a subnetwork from it

Select the node name "GQ377772"
```{r}
selectNodes(cw2, "GQ377772") 
getSelectedNodes(cw2)
```

```{r}
selectFirstNeighborsOfSelectedNodes(cw2)
getSelectedNodes(cw2)
```

Select the neighbors of the node
```{r}
selectFirstNeighborsOfSelectedNodes(cw2)
getSelectedNodes(cw2)
```

Create a subnetwork from these nodes and their edges
```{r}
newnet <- createWindowFromSelection(cw2,
                                    "subnet",
                                    "TRUE")
```

Display 
```{r}
layoutNetwork(newnet, "force-directed")

```




