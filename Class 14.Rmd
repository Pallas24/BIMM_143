---
title: "Class 14"
author: "Pallas Duong"
date: "5/17/2018"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

#Import countData and colData into R

```{r}
counts <- read.csv("data/airway_scaledcounts.csv", stringsAsFactors = FALSE)
metadata <-  read.csv("data/airway_metadata.csv", stringsAsFactors = FALSE)
head(counts)
head(metadata)
```

#Toy differntial gene expression 

Calcualte the mean counts per gene across the samples
```{r}
#Control sample 
control <- metadata[metadata[,"dex"]=="control",]
control.mean <- rowSums( counts[ ,control$id] )/4 
names(control.mean) <- counts$ensgene
head(control.mean)

```
**Q1** I can make the code above more robust by replace '4' by the number of samples in metadata (length(control$id)). If you add more sample, the code above would give wrong results since there would be more than 4 samples. 

**Q2**
```{r}
#Treatment smaple 
treatment <- metadata[metadata[, "dex"]=="treated",]
treated.mean <- rowSums(counts[, treatment$id])/length(control$id)
names(treated.mean) <- counts$ensgene
head(treated.mean)
```


Combine meancount data for bookkeeping purposes
```{r}
meancounts <- data.frame(control.mean, treated.mean)
```

Normalize be sequencing depth per sample
```{r}
colSums(meancounts)
```

**Q3** Scatter plot showing the mean of the treated samples against the mean of the control samples 
```{r}
plot(meancounts, 
     log = "xy", 
     xlab = "log Control", 
     ylab = "log Treatment")
```

Calculate log2foldchange an add it to 'meancounts' data fram and inspect the results
```{r}
meancounts$log2fc <- log2(meancounts[,"treated.mean"]/meancounts[,"control.mean"])
head(meancounts)
```

Inspect the result for NaN and -Inf
```{r}
zero.vals <- which(meancounts[,1:2]==0, arr.ind=TRUE)

to.rm <- unique(zero.vals[,1])
mycounts <- meancounts[-to.rm,]
head(mycounts)
```

**Q4** The purpose of the arr.ind argument in the which() function called above is to indacate should array indices be return when x is an array. We need to take the first column of the output and need to call the unique() function because the function would returns a vector/data frame/array with duplicated elements removed

Filter the dataset to see how many genes are up or down-regulated 
```{r}
up.ind <- mycounts$log2fc > 2
down.ind <- mycounts$log2fc < (-2)
```

**Q5** How many genes are up or down-regulated 
```{r}
Up <- paste("Up:", sum(up.ind))
Down <- paste("Down:", sum(down.ind))
Up
Down
```

#Adding annotation data 

Add annotatin from supplied CSV file 
```{r}
anno <- read.csv("data/annotables_grch38.csv")
head(anno)
```

**Q6**
```{r}
results <- merge(mycounts, anno, by.x = "row.names", by.y = "ensgene")
results
```

Load the AnnotationDbi package and annotate package org.Hs.eg.db
```{r}
library("AnnotationDbi")
library("org.Hs.eg.db")
```

```{r}
columns(org.Hs.eg.db)
```


List of all avaible key types
```{r}
columns(org.Hs.eg.db)
```

Add individual columns to the results table 
```{r}
mycounts$symbol <- mapIds(org.Hs.eg.db,
                     keys=row.names(mycounts),
                     column="SYMBOL",
                     keytype="ENSEMBL",
                     multiVals="first")
```

**Q7** 
```{r}
#Add Entriz ID
mycounts$entrez <- mapIds(org.Hs.eg.db,
                     keys=row.names(mycounts),
                     column="ENTREZID",
                     keytype="ENSEMBL",
                     multiVals="first")

#Add Uniprot
mycounts$uniprot <- mapIds(org.Hs.eg.db,
                     keys=row.names(mycounts),
                     column="UNIPROT",
                     keytype="ENSEMBL",
                     multiVals="first")
head(mycounts)
```

**Q8**
```{r}
head(mycounts[up.ind,])
```

#DESeq2 analysis

Load the package
```{r}
library(DESeq2)
citation("DESeq2")
```

##Impoting data
```{r}
dds <- DESeqDataSetFromMatrix(countData=counts, colData=metadata, design=~dex,tidy=TRUE)
dds
```

##DESeq pipeline 
```{r}
sizeFactors(dds)
dispersions(dds)
results(dds)
```

```{r}
dds <- DESeq(dds)
```

##Getting results 
```{r}
res <- results(dds)
res
```

```{r}
summary(res)
```

```{r}
resOrdered <- res[order(res$pvalue),]
res05 <- results(dds, alpha=0.05)
summary(res05)
```

```{r}
resSig05 <- subset(as.data.frame(res), padj < 0.05)
nrow(resSig05)
```
**Q9** 
```{r}
resSig01<- subset(as.data.frame(res), padj < 0.01)
nrow(resSig01)
```

**Q10**
```{r}
res01 <- results(dds, alpha=0.01)
summary(res01)

resSig01$symbol <- mapIds(org.Hs.eg.db,
                     keys=row.names(resSig01),
                     column="SYMBOL",
                     keytype="ENSEMBL",
                     multiVals="first")
```

Arrange and view the results by the adjusted p-value
```{r}
ord <- order( resSig01$padj )
#View(res01[ord,])
head(resSig01[ord,])
```

Write out the ordered significant results with annotations
```{r}
write.csv(resSig01[ord,], "signif01_results.csv")
```

#Data Visuallizatin
##Plotting counts 

What is the gene ID for the CRISPLD2 gene?
```{r}
i <- grep("CRISPLD2", resSig01$symbol)
resSig01[i,]

rownames(resSig01[i,])
```

Plot the counts
```{r}
plotCounts(dds, gene="ENSG00000103196", intgroup="dex")

```

Make boxplot
```{r}
# Return the data
d <- plotCounts(dds, gene="ENSG00000103196", intgroup="dex", returnData=TRUE)
head(d)

#Boxplot
boxplot(count ~ dex , data=d)

```

ggplot2 
```{r}
library(ggplot2)
ggplot(d, aes(dex, count)) + geom_boxplot(aes(fill=dex)) + scale_y_log10() + ggtitle("CRISPLD2")
```

##MA & Volcano plots 

Add a column to results 
```{r}
res$sig <- res$padj<0.05

# How many of each?
table(res$sig)

#Sum
sum(is.na(res$sig))
```

##In built MA-plot
```{r}
plotMA(res, ylim=c(-2,2))
```

Shrunken log2 fold changes 
```{r}
resLFC <- lfcShrink(dds, coef=2)
resLFC
plotMA(resLFC, ylim=c(-2,2))

```

##Volcano plot 

Mke a volcano plot
```{r}
ggplot(as.data.frame(res), aes(log2FoldChange, -1*log10(pvalue), col=sig)) + 
    geom_point() + 
    ggtitle("Volcano plot")
```

#Side-note: Transformation
```{r}
vsdata <- vst(dds, blind=FALSE)
```

##PCA
```{r}
plotPCA(vsdata, intgroup="dex")

```

#Session Information
```{r}
sessionInfo()

```

